/*
 * generated by Xtext 2.27.0
 */
package nl.tue.gtl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import nl.tue.gtl.domainmodel.Add_Expression;
import nl.tue.gtl.domainmodel.And_Expression;
import nl.tue.gtl.domainmodel.Divide_Expression;
import nl.tue.gtl.domainmodel.DomainmodelPackage;
import nl.tue.gtl.domainmodel.Equals_Expression;
import nl.tue.gtl.domainmodel.Greater_Expression;
import nl.tue.gtl.domainmodel.Less_Expression;
import nl.tue.gtl.domainmodel.Multiply_Expression;
import nl.tue.gtl.domainmodel.NotEquals_Expression;
import nl.tue.gtl.domainmodel.Or_Expression;
import nl.tue.gtl.domainmodel.Subtract_Expression;
import nl.tue.gtl.domainmodel.TQL;
import nl.tue.gtl.services.TQLGrammarAccess;
import nl.tue.gtl.tql.model.BooleanConstant;
import nl.tue.gtl.tql.model.Column;
import nl.tue.gtl.tql.model.ColumnExpression;
import nl.tue.gtl.tql.model.ConstantCallParameter;
import nl.tue.gtl.tql.model.FloatConstant;
import nl.tue.gtl.tql.model.IntegerConstant;
import nl.tue.gtl.tql.model.MappedColumn;
import nl.tue.gtl.tql.model.Mapping;
import nl.tue.gtl.tql.model.ModelPackage;
import nl.tue.gtl.tql.model.NullConstant;
import nl.tue.gtl.tql.model.ParameterExpression;
import nl.tue.gtl.tql.model.ReferenceCallParameter;
import nl.tue.gtl.tql.model.SelfExpression;
import nl.tue.gtl.tql.model.SetConstant;
import nl.tue.gtl.tql.model.SourceTable;
import nl.tue.gtl.tql.model.StringConstant;
import nl.tue.gtl.tql.model.TargetTable;
import nl.tue.gtl.tql.model.Transformation;
import nl.tue.gtl.tql.model.TransformationCall;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class TQLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TQLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DomainmodelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DomainmodelPackage.ADD_EXPRESSION:
				sequence_Add_Expression(context, (Add_Expression) semanticObject); 
				return; 
			case DomainmodelPackage.AND_EXPRESSION:
				sequence_And_Expression(context, (And_Expression) semanticObject); 
				return; 
			case DomainmodelPackage.DIVIDE_EXPRESSION:
				sequence_Divide_Expression(context, (Divide_Expression) semanticObject); 
				return; 
			case DomainmodelPackage.EQUALS_EXPRESSION:
				sequence_Equals_Expression(context, (Equals_Expression) semanticObject); 
				return; 
			case DomainmodelPackage.GREATER_EXPRESSION:
				sequence_Greater_Expression(context, (Greater_Expression) semanticObject); 
				return; 
			case DomainmodelPackage.LESS_EXPRESSION:
				sequence_Less_Expression(context, (Less_Expression) semanticObject); 
				return; 
			case DomainmodelPackage.MULTIPLY_EXPRESSION:
				sequence_Multiply_Expression(context, (Multiply_Expression) semanticObject); 
				return; 
			case DomainmodelPackage.NOT_EQUALS_EXPRESSION:
				sequence_NotEquals_Expression(context, (NotEquals_Expression) semanticObject); 
				return; 
			case DomainmodelPackage.OR_EXPRESSION:
				sequence_Or_Expression(context, (Or_Expression) semanticObject); 
				return; 
			case DomainmodelPackage.SUBTRACT_EXPRESSION:
				sequence_Subtract_Expression(context, (Subtract_Expression) semanticObject); 
				return; 
			case DomainmodelPackage.TQL:
				sequence_TQL(context, (TQL) semanticObject); 
				return; 
			}
		else if (epackage == ModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ModelPackage.BOOLEAN_CONSTANT:
				sequence_Boolean_Constant(context, (BooleanConstant) semanticObject); 
				return; 
			case ModelPackage.COLUMN:
				sequence_Column(context, (Column) semanticObject); 
				return; 
			case ModelPackage.COLUMN_EXPRESSION:
				sequence_Column_Expression(context, (ColumnExpression) semanticObject); 
				return; 
			case ModelPackage.CONSTANT_CALL_PARAMETER:
				sequence_Constant_Call_Parameter(context, (ConstantCallParameter) semanticObject); 
				return; 
			case ModelPackage.FLOAT_CONSTANT:
				sequence_Float_Constant(context, (FloatConstant) semanticObject); 
				return; 
			case ModelPackage.INTEGER_CONSTANT:
				sequence_Integer_Constant(context, (IntegerConstant) semanticObject); 
				return; 
			case ModelPackage.MAPPED_COLUMN:
				sequence_Mapped_Column(context, (MappedColumn) semanticObject); 
				return; 
			case ModelPackage.MAPPING:
				sequence_Mapping(context, (Mapping) semanticObject); 
				return; 
			case ModelPackage.NULL_CONSTANT:
				sequence_Null_Constant(context, (NullConstant) semanticObject); 
				return; 
			case ModelPackage.PARAMETER:
				sequence_Parameter(context, (nl.tue.gtl.tql.model.Parameter) semanticObject); 
				return; 
			case ModelPackage.PARAMETER_EXPRESSION:
				sequence_Parameter_Expression(context, (ParameterExpression) semanticObject); 
				return; 
			case ModelPackage.REFERENCE_CALL_PARAMETER:
				sequence_Reference_Call_Parameter(context, (ReferenceCallParameter) semanticObject); 
				return; 
			case ModelPackage.SELF_EXPRESSION:
				sequence_Self_Expression(context, (SelfExpression) semanticObject); 
				return; 
			case ModelPackage.SET_CONSTANT:
				sequence_Set_Constant(context, (SetConstant) semanticObject); 
				return; 
			case ModelPackage.SOURCE_TABLE:
				sequence_Source_Table(context, (SourceTable) semanticObject); 
				return; 
			case ModelPackage.STRING_CONSTANT:
				sequence_String_Constant(context, (StringConstant) semanticObject); 
				return; 
			case ModelPackage.TARGET_TABLE:
				sequence_Target_Table(context, (TargetTable) semanticObject); 
				return; 
			case ModelPackage.TRANSFORMATION:
				sequence_Transformation(context, (Transformation) semanticObject); 
				return; 
			case ModelPackage.TRANSFORMATION_CALL:
				sequence_Transformation_Call(context, (TransformationCall) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Add_Expression
	 *     And_Expression returns Add_Expression
	 *     And_Expression.And_Expression_1_0 returns Add_Expression
	 *     Or_Expression returns Add_Expression
	 *     Or_Expression.Or_Expression_1_0 returns Add_Expression
	 *     Equals_Expression returns Add_Expression
	 *     Equals_Expression.Equals_Expression_1_0 returns Add_Expression
	 *     NotEquals_Expression returns Add_Expression
	 *     NotEquals_Expression.NotEquals_Expression_1_0 returns Add_Expression
	 *     Less_Expression returns Add_Expression
	 *     Less_Expression.Less_Expression_1_0 returns Add_Expression
	 *     Greater_Expression returns Add_Expression
	 *     Greater_Expression.Greater_Expression_1_0 returns Add_Expression
	 *     Multiply_Expression returns Add_Expression
	 *     Multiply_Expression.Multiply_Expression_1_0 returns Add_Expression
	 *     Divide_Expression returns Add_Expression
	 *     Divide_Expression.Divide_Expression_1_0 returns Add_Expression
	 *     Add_Expression returns Add_Expression
	 *     Add_Expression.Add_Expression_1_0 returns Add_Expression
	 *
	 * Constraint:
	 *     (left=Add_Expression_Add_Expression_1_0 operator=AddOperator right=Subtract_Expression)
	 * </pre>
	 */
	protected void sequence_Add_Expression(ISerializationContext context, Add_Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.ADD_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.ADD_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.ADD_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.ADD_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.ADD_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.ADD_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdd_ExpressionAccess().getAdd_ExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdd_ExpressionAccess().getOperatorAddOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getAdd_ExpressionAccess().getRightSubtract_ExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns And_Expression
	 *     And_Expression returns And_Expression
	 *     And_Expression.And_Expression_1_0 returns And_Expression
	 *
	 * Constraint:
	 *     (left=And_Expression_And_Expression_1_0 operator=AndOperator right=Or_Expression)
	 * </pre>
	 */
	protected void sequence_And_Expression(ISerializationContext context, And_Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.AND_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.AND_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.AND_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.AND_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.AND_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.AND_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnd_ExpressionAccess().getAnd_ExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAnd_ExpressionAccess().getOperatorAndOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getAnd_ExpressionAccess().getRightOr_ExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns BooleanConstant
	 *     And_Expression returns BooleanConstant
	 *     And_Expression.And_Expression_1_0 returns BooleanConstant
	 *     Or_Expression returns BooleanConstant
	 *     Or_Expression.Or_Expression_1_0 returns BooleanConstant
	 *     Equals_Expression returns BooleanConstant
	 *     Equals_Expression.Equals_Expression_1_0 returns BooleanConstant
	 *     NotEquals_Expression returns BooleanConstant
	 *     NotEquals_Expression.NotEquals_Expression_1_0 returns BooleanConstant
	 *     Less_Expression returns BooleanConstant
	 *     Less_Expression.Less_Expression_1_0 returns BooleanConstant
	 *     Greater_Expression returns BooleanConstant
	 *     Greater_Expression.Greater_Expression_1_0 returns BooleanConstant
	 *     Multiply_Expression returns BooleanConstant
	 *     Multiply_Expression.Multiply_Expression_1_0 returns BooleanConstant
	 *     Divide_Expression returns BooleanConstant
	 *     Divide_Expression.Divide_Expression_1_0 returns BooleanConstant
	 *     Add_Expression returns BooleanConstant
	 *     Add_Expression.Add_Expression_1_0 returns BooleanConstant
	 *     Subtract_Expression returns BooleanConstant
	 *     Subtract_Expression.Subtract_Expression_1_0 returns BooleanConstant
	 *     Literal_Expression returns BooleanConstant
	 *     Constant returns BooleanConstant
	 *     Single_Constant returns BooleanConstant
	 *     Boolean_Constant returns BooleanConstant
	 *
	 * Constraint:
	 *     value=EBoolean
	 * </pre>
	 */
	protected void sequence_Boolean_Constant(ISerializationContext context, BooleanConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.BOOLEAN_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.BOOLEAN_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolean_ConstantAccess().getValueEBooleanParserRuleCall_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Column returns Column
	 *
	 * Constraint:
	 *     (name=EString type=Type)
	 * </pre>
	 */
	protected void sequence_Column(ISerializationContext context, Column semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.COLUMN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.COLUMN__NAME));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.COLUMN__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.COLUMN__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColumnAccess().getNameEStringParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getColumnAccess().getTypeTypeEnumRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Column_Expression returns ColumnExpression
	 *
	 * Constraint:
	 *     column=[Column|EString]
	 * </pre>
	 */
	protected void sequence_Column_Expression(ISerializationContext context, ColumnExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.COLUMN_EXPRESSION__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.COLUMN_EXPRESSION__COLUMN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColumn_ExpressionAccess().getColumnColumnEStringParserRuleCall_0_1(), semanticObject.eGet(ModelPackage.Literals.COLUMN_EXPRESSION__COLUMN, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Call_Parameter returns ConstantCallParameter
	 *     Constant_Call_Parameter returns ConstantCallParameter
	 *
	 * Constraint:
	 *     parameter=Constant
	 * </pre>
	 */
	protected void sequence_Constant_Call_Parameter(ISerializationContext context, ConstantCallParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.CONSTANT_CALL_PARAMETER__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.CONSTANT_CALL_PARAMETER__PARAMETER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstant_Call_ParameterAccess().getParameterConstantParserRuleCall_0(), semanticObject.getParameter());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Divide_Expression
	 *     And_Expression returns Divide_Expression
	 *     And_Expression.And_Expression_1_0 returns Divide_Expression
	 *     Or_Expression returns Divide_Expression
	 *     Or_Expression.Or_Expression_1_0 returns Divide_Expression
	 *     Equals_Expression returns Divide_Expression
	 *     Equals_Expression.Equals_Expression_1_0 returns Divide_Expression
	 *     NotEquals_Expression returns Divide_Expression
	 *     NotEquals_Expression.NotEquals_Expression_1_0 returns Divide_Expression
	 *     Less_Expression returns Divide_Expression
	 *     Less_Expression.Less_Expression_1_0 returns Divide_Expression
	 *     Greater_Expression returns Divide_Expression
	 *     Greater_Expression.Greater_Expression_1_0 returns Divide_Expression
	 *     Multiply_Expression returns Divide_Expression
	 *     Multiply_Expression.Multiply_Expression_1_0 returns Divide_Expression
	 *     Divide_Expression returns Divide_Expression
	 *     Divide_Expression.Divide_Expression_1_0 returns Divide_Expression
	 *
	 * Constraint:
	 *     (left=Divide_Expression_Divide_Expression_1_0 operator=DivideOperator right=Add_Expression)
	 * </pre>
	 */
	protected void sequence_Divide_Expression(ISerializationContext context, Divide_Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.DIVIDE_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.DIVIDE_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.DIVIDE_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.DIVIDE_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.DIVIDE_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.DIVIDE_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDivide_ExpressionAccess().getDivide_ExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getDivide_ExpressionAccess().getOperatorDivideOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getDivide_ExpressionAccess().getRightAdd_ExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Equals_Expression
	 *     And_Expression returns Equals_Expression
	 *     And_Expression.And_Expression_1_0 returns Equals_Expression
	 *     Or_Expression returns Equals_Expression
	 *     Or_Expression.Or_Expression_1_0 returns Equals_Expression
	 *     Equals_Expression returns Equals_Expression
	 *     Equals_Expression.Equals_Expression_1_0 returns Equals_Expression
	 *
	 * Constraint:
	 *     (left=Equals_Expression_Equals_Expression_1_0 operator=EqualsOperator right=NotEquals_Expression)
	 * </pre>
	 */
	protected void sequence_Equals_Expression(ISerializationContext context, Equals_Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.EQUALS_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.EQUALS_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.EQUALS_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.EQUALS_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.EQUALS_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.EQUALS_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEquals_ExpressionAccess().getEquals_ExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEquals_ExpressionAccess().getOperatorEqualsOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getEquals_ExpressionAccess().getRightNotEquals_ExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns FloatConstant
	 *     And_Expression returns FloatConstant
	 *     And_Expression.And_Expression_1_0 returns FloatConstant
	 *     Or_Expression returns FloatConstant
	 *     Or_Expression.Or_Expression_1_0 returns FloatConstant
	 *     Equals_Expression returns FloatConstant
	 *     Equals_Expression.Equals_Expression_1_0 returns FloatConstant
	 *     NotEquals_Expression returns FloatConstant
	 *     NotEquals_Expression.NotEquals_Expression_1_0 returns FloatConstant
	 *     Less_Expression returns FloatConstant
	 *     Less_Expression.Less_Expression_1_0 returns FloatConstant
	 *     Greater_Expression returns FloatConstant
	 *     Greater_Expression.Greater_Expression_1_0 returns FloatConstant
	 *     Multiply_Expression returns FloatConstant
	 *     Multiply_Expression.Multiply_Expression_1_0 returns FloatConstant
	 *     Divide_Expression returns FloatConstant
	 *     Divide_Expression.Divide_Expression_1_0 returns FloatConstant
	 *     Add_Expression returns FloatConstant
	 *     Add_Expression.Add_Expression_1_0 returns FloatConstant
	 *     Subtract_Expression returns FloatConstant
	 *     Subtract_Expression.Subtract_Expression_1_0 returns FloatConstant
	 *     Literal_Expression returns FloatConstant
	 *     Constant returns FloatConstant
	 *     Single_Constant returns FloatConstant
	 *     Float_Constant returns FloatConstant
	 *
	 * Constraint:
	 *     value=EFloat
	 * </pre>
	 */
	protected void sequence_Float_Constant(ISerializationContext context, FloatConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.FLOAT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.FLOAT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFloat_ConstantAccess().getValueEFloatParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Greater_Expression
	 *     And_Expression returns Greater_Expression
	 *     And_Expression.And_Expression_1_0 returns Greater_Expression
	 *     Or_Expression returns Greater_Expression
	 *     Or_Expression.Or_Expression_1_0 returns Greater_Expression
	 *     Equals_Expression returns Greater_Expression
	 *     Equals_Expression.Equals_Expression_1_0 returns Greater_Expression
	 *     NotEquals_Expression returns Greater_Expression
	 *     NotEquals_Expression.NotEquals_Expression_1_0 returns Greater_Expression
	 *     Less_Expression returns Greater_Expression
	 *     Less_Expression.Less_Expression_1_0 returns Greater_Expression
	 *     Greater_Expression returns Greater_Expression
	 *     Greater_Expression.Greater_Expression_1_0 returns Greater_Expression
	 *
	 * Constraint:
	 *     (left=Greater_Expression_Greater_Expression_1_0 operator=GreaterOperator right=Multiply_Expression)
	 * </pre>
	 */
	protected void sequence_Greater_Expression(ISerializationContext context, Greater_Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.GREATER_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.GREATER_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.GREATER_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.GREATER_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.GREATER_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.GREATER_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGreater_ExpressionAccess().getGreater_ExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getGreater_ExpressionAccess().getOperatorGreaterOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getGreater_ExpressionAccess().getRightMultiply_ExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns IntegerConstant
	 *     And_Expression returns IntegerConstant
	 *     And_Expression.And_Expression_1_0 returns IntegerConstant
	 *     Or_Expression returns IntegerConstant
	 *     Or_Expression.Or_Expression_1_0 returns IntegerConstant
	 *     Equals_Expression returns IntegerConstant
	 *     Equals_Expression.Equals_Expression_1_0 returns IntegerConstant
	 *     NotEquals_Expression returns IntegerConstant
	 *     NotEquals_Expression.NotEquals_Expression_1_0 returns IntegerConstant
	 *     Less_Expression returns IntegerConstant
	 *     Less_Expression.Less_Expression_1_0 returns IntegerConstant
	 *     Greater_Expression returns IntegerConstant
	 *     Greater_Expression.Greater_Expression_1_0 returns IntegerConstant
	 *     Multiply_Expression returns IntegerConstant
	 *     Multiply_Expression.Multiply_Expression_1_0 returns IntegerConstant
	 *     Divide_Expression returns IntegerConstant
	 *     Divide_Expression.Divide_Expression_1_0 returns IntegerConstant
	 *     Add_Expression returns IntegerConstant
	 *     Add_Expression.Add_Expression_1_0 returns IntegerConstant
	 *     Subtract_Expression returns IntegerConstant
	 *     Subtract_Expression.Subtract_Expression_1_0 returns IntegerConstant
	 *     Literal_Expression returns IntegerConstant
	 *     Constant returns IntegerConstant
	 *     Single_Constant returns IntegerConstant
	 *     Integer_Constant returns IntegerConstant
	 *
	 * Constraint:
	 *     value=EInt
	 * </pre>
	 */
	protected void sequence_Integer_Constant(ISerializationContext context, IntegerConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.INTEGER_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.INTEGER_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInteger_ConstantAccess().getValueEIntParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Less_Expression
	 *     And_Expression returns Less_Expression
	 *     And_Expression.And_Expression_1_0 returns Less_Expression
	 *     Or_Expression returns Less_Expression
	 *     Or_Expression.Or_Expression_1_0 returns Less_Expression
	 *     Equals_Expression returns Less_Expression
	 *     Equals_Expression.Equals_Expression_1_0 returns Less_Expression
	 *     NotEquals_Expression returns Less_Expression
	 *     NotEquals_Expression.NotEquals_Expression_1_0 returns Less_Expression
	 *     Less_Expression returns Less_Expression
	 *     Less_Expression.Less_Expression_1_0 returns Less_Expression
	 *
	 * Constraint:
	 *     (left=Less_Expression_Less_Expression_1_0 operator=LessOperator right=Greater_Expression)
	 * </pre>
	 */
	protected void sequence_Less_Expression(ISerializationContext context, Less_Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.LESS_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.LESS_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.LESS_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.LESS_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.LESS_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.LESS_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLess_ExpressionAccess().getLess_ExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLess_ExpressionAccess().getOperatorLessOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getLess_ExpressionAccess().getRightGreater_ExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mapped_Column returns MappedColumn
	 *
	 * Constraint:
	 *     (target=[Column|EString] source=[Column|EString] transformationCalls+=Transformation_Call*)
	 * </pre>
	 */
	protected void sequence_Mapped_Column(ISerializationContext context, MappedColumn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Block returns Mapping
	 *     Mapping returns Mapping
	 *
	 * Constraint:
	 *     (source=[SourceTable|EString] target=[TargetTable|EString] mappedColumns+=Mapped_Column mappedColumns+=Mapped_Column*)
	 * </pre>
	 */
	protected void sequence_Mapping(ISerializationContext context, Mapping semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Multiply_Expression
	 *     And_Expression returns Multiply_Expression
	 *     And_Expression.And_Expression_1_0 returns Multiply_Expression
	 *     Or_Expression returns Multiply_Expression
	 *     Or_Expression.Or_Expression_1_0 returns Multiply_Expression
	 *     Equals_Expression returns Multiply_Expression
	 *     Equals_Expression.Equals_Expression_1_0 returns Multiply_Expression
	 *     NotEquals_Expression returns Multiply_Expression
	 *     NotEquals_Expression.NotEquals_Expression_1_0 returns Multiply_Expression
	 *     Less_Expression returns Multiply_Expression
	 *     Less_Expression.Less_Expression_1_0 returns Multiply_Expression
	 *     Greater_Expression returns Multiply_Expression
	 *     Greater_Expression.Greater_Expression_1_0 returns Multiply_Expression
	 *     Multiply_Expression returns Multiply_Expression
	 *     Multiply_Expression.Multiply_Expression_1_0 returns Multiply_Expression
	 *
	 * Constraint:
	 *     (left=Multiply_Expression_Multiply_Expression_1_0 operator=MultiplyOperator right=Divide_Expression)
	 * </pre>
	 */
	protected void sequence_Multiply_Expression(ISerializationContext context, Multiply_Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.MULTIPLY_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.MULTIPLY_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.MULTIPLY_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.MULTIPLY_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.MULTIPLY_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.MULTIPLY_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiply_ExpressionAccess().getMultiply_ExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiply_ExpressionAccess().getOperatorMultiplyOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getMultiply_ExpressionAccess().getRightDivide_ExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns NotEquals_Expression
	 *     And_Expression returns NotEquals_Expression
	 *     And_Expression.And_Expression_1_0 returns NotEquals_Expression
	 *     Or_Expression returns NotEquals_Expression
	 *     Or_Expression.Or_Expression_1_0 returns NotEquals_Expression
	 *     Equals_Expression returns NotEquals_Expression
	 *     Equals_Expression.Equals_Expression_1_0 returns NotEquals_Expression
	 *     NotEquals_Expression returns NotEquals_Expression
	 *     NotEquals_Expression.NotEquals_Expression_1_0 returns NotEquals_Expression
	 *
	 * Constraint:
	 *     (left=NotEquals_Expression_NotEquals_Expression_1_0 operator=NotEqualsOperator right=Less_Expression)
	 * </pre>
	 */
	protected void sequence_NotEquals_Expression(ISerializationContext context, NotEquals_Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.NOT_EQUALS_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.NOT_EQUALS_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.NOT_EQUALS_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.NOT_EQUALS_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.NOT_EQUALS_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.NOT_EQUALS_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotEquals_ExpressionAccess().getNotEquals_ExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getNotEquals_ExpressionAccess().getOperatorNotEqualsOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getNotEquals_ExpressionAccess().getRightLess_ExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns NullConstant
	 *     And_Expression returns NullConstant
	 *     And_Expression.And_Expression_1_0 returns NullConstant
	 *     Or_Expression returns NullConstant
	 *     Or_Expression.Or_Expression_1_0 returns NullConstant
	 *     Equals_Expression returns NullConstant
	 *     Equals_Expression.Equals_Expression_1_0 returns NullConstant
	 *     NotEquals_Expression returns NullConstant
	 *     NotEquals_Expression.NotEquals_Expression_1_0 returns NullConstant
	 *     Less_Expression returns NullConstant
	 *     Less_Expression.Less_Expression_1_0 returns NullConstant
	 *     Greater_Expression returns NullConstant
	 *     Greater_Expression.Greater_Expression_1_0 returns NullConstant
	 *     Multiply_Expression returns NullConstant
	 *     Multiply_Expression.Multiply_Expression_1_0 returns NullConstant
	 *     Divide_Expression returns NullConstant
	 *     Divide_Expression.Divide_Expression_1_0 returns NullConstant
	 *     Add_Expression returns NullConstant
	 *     Add_Expression.Add_Expression_1_0 returns NullConstant
	 *     Subtract_Expression returns NullConstant
	 *     Subtract_Expression.Subtract_Expression_1_0 returns NullConstant
	 *     Literal_Expression returns NullConstant
	 *     Constant returns NullConstant
	 *     Single_Constant returns NullConstant
	 *     Null_Constant returns NullConstant
	 *
	 * Constraint:
	 *     {NullConstant}
	 * </pre>
	 */
	protected void sequence_Null_Constant(ISerializationContext context, NullConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Or_Expression
	 *     And_Expression returns Or_Expression
	 *     And_Expression.And_Expression_1_0 returns Or_Expression
	 *     Or_Expression returns Or_Expression
	 *     Or_Expression.Or_Expression_1_0 returns Or_Expression
	 *
	 * Constraint:
	 *     (left=Or_Expression_Or_Expression_1_0 operator=OrOperator right=Equals_Expression)
	 * </pre>
	 */
	protected void sequence_Or_Expression(ISerializationContext context, Or_Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.OR_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.OR_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOr_ExpressionAccess().getOr_ExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOr_ExpressionAccess().getOperatorOrOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getOr_ExpressionAccess().getRightEquals_ExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns ParameterExpression
	 *     And_Expression returns ParameterExpression
	 *     And_Expression.And_Expression_1_0 returns ParameterExpression
	 *     Or_Expression returns ParameterExpression
	 *     Or_Expression.Or_Expression_1_0 returns ParameterExpression
	 *     Equals_Expression returns ParameterExpression
	 *     Equals_Expression.Equals_Expression_1_0 returns ParameterExpression
	 *     NotEquals_Expression returns ParameterExpression
	 *     NotEquals_Expression.NotEquals_Expression_1_0 returns ParameterExpression
	 *     Less_Expression returns ParameterExpression
	 *     Less_Expression.Less_Expression_1_0 returns ParameterExpression
	 *     Greater_Expression returns ParameterExpression
	 *     Greater_Expression.Greater_Expression_1_0 returns ParameterExpression
	 *     Multiply_Expression returns ParameterExpression
	 *     Multiply_Expression.Multiply_Expression_1_0 returns ParameterExpression
	 *     Divide_Expression returns ParameterExpression
	 *     Divide_Expression.Divide_Expression_1_0 returns ParameterExpression
	 *     Add_Expression returns ParameterExpression
	 *     Add_Expression.Add_Expression_1_0 returns ParameterExpression
	 *     Subtract_Expression returns ParameterExpression
	 *     Subtract_Expression.Subtract_Expression_1_0 returns ParameterExpression
	 *     Literal_Expression returns ParameterExpression
	 *     Parameter_Expression returns ParameterExpression
	 *
	 * Constraint:
	 *     parameter=[Parameter|EString]
	 * </pre>
	 */
	protected void sequence_Parameter_Expression(ISerializationContext context, ParameterExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.PARAMETER_EXPRESSION__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.PARAMETER_EXPRESSION__PARAMETER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameter_ExpressionAccess().getParameterParameterEStringParserRuleCall_0_1(), semanticObject.eGet(ModelPackage.Literals.PARAMETER_EXPRESSION__PARAMETER, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (name=EString type=Type)
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, nl.tue.gtl.tql.model.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.PARAMETER__NAME));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.PARAMETER__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameEStringParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterAccess().getTypeTypeEnumRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Call_Parameter returns ReferenceCallParameter
	 *     Reference_Call_Parameter returns ReferenceCallParameter
	 *
	 * Constraint:
	 *     reference=[Column|EString]
	 * </pre>
	 */
	protected void sequence_Reference_Call_Parameter(ISerializationContext context, ReferenceCallParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.REFERENCE_CALL_PARAMETER__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.REFERENCE_CALL_PARAMETER__REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReference_Call_ParameterAccess().getReferenceColumnEStringParserRuleCall_0_1(), semanticObject.eGet(ModelPackage.Literals.REFERENCE_CALL_PARAMETER__REFERENCE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns SelfExpression
	 *     And_Expression returns SelfExpression
	 *     And_Expression.And_Expression_1_0 returns SelfExpression
	 *     Or_Expression returns SelfExpression
	 *     Or_Expression.Or_Expression_1_0 returns SelfExpression
	 *     Equals_Expression returns SelfExpression
	 *     Equals_Expression.Equals_Expression_1_0 returns SelfExpression
	 *     NotEquals_Expression returns SelfExpression
	 *     NotEquals_Expression.NotEquals_Expression_1_0 returns SelfExpression
	 *     Less_Expression returns SelfExpression
	 *     Less_Expression.Less_Expression_1_0 returns SelfExpression
	 *     Greater_Expression returns SelfExpression
	 *     Greater_Expression.Greater_Expression_1_0 returns SelfExpression
	 *     Multiply_Expression returns SelfExpression
	 *     Multiply_Expression.Multiply_Expression_1_0 returns SelfExpression
	 *     Divide_Expression returns SelfExpression
	 *     Divide_Expression.Divide_Expression_1_0 returns SelfExpression
	 *     Add_Expression returns SelfExpression
	 *     Add_Expression.Add_Expression_1_0 returns SelfExpression
	 *     Subtract_Expression returns SelfExpression
	 *     Subtract_Expression.Subtract_Expression_1_0 returns SelfExpression
	 *     Literal_Expression returns SelfExpression
	 *     Self_Expression returns SelfExpression
	 *
	 * Constraint:
	 *     {SelfExpression}
	 * </pre>
	 */
	protected void sequence_Self_Expression(ISerializationContext context, SelfExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns SetConstant
	 *     And_Expression returns SetConstant
	 *     And_Expression.And_Expression_1_0 returns SetConstant
	 *     Or_Expression returns SetConstant
	 *     Or_Expression.Or_Expression_1_0 returns SetConstant
	 *     Equals_Expression returns SetConstant
	 *     Equals_Expression.Equals_Expression_1_0 returns SetConstant
	 *     NotEquals_Expression returns SetConstant
	 *     NotEquals_Expression.NotEquals_Expression_1_0 returns SetConstant
	 *     Less_Expression returns SetConstant
	 *     Less_Expression.Less_Expression_1_0 returns SetConstant
	 *     Greater_Expression returns SetConstant
	 *     Greater_Expression.Greater_Expression_1_0 returns SetConstant
	 *     Multiply_Expression returns SetConstant
	 *     Multiply_Expression.Multiply_Expression_1_0 returns SetConstant
	 *     Divide_Expression returns SetConstant
	 *     Divide_Expression.Divide_Expression_1_0 returns SetConstant
	 *     Add_Expression returns SetConstant
	 *     Add_Expression.Add_Expression_1_0 returns SetConstant
	 *     Subtract_Expression returns SetConstant
	 *     Subtract_Expression.Subtract_Expression_1_0 returns SetConstant
	 *     Literal_Expression returns SetConstant
	 *     Constant returns SetConstant
	 *     Set_Constant returns SetConstant
	 *
	 * Constraint:
	 *     (values+=Single_Constant values+=Single_Constant*)?
	 * </pre>
	 */
	protected void sequence_Set_Constant(ISerializationContext context, SetConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Block returns SourceTable
	 *     Table_Impl returns SourceTable
	 *     Source_Table returns SourceTable
	 *
	 * Constraint:
	 *     (name=EString columns+=Column columns+=Column*)
	 * </pre>
	 */
	protected void sequence_Source_Table(ISerializationContext context, SourceTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns StringConstant
	 *     And_Expression returns StringConstant
	 *     And_Expression.And_Expression_1_0 returns StringConstant
	 *     Or_Expression returns StringConstant
	 *     Or_Expression.Or_Expression_1_0 returns StringConstant
	 *     Equals_Expression returns StringConstant
	 *     Equals_Expression.Equals_Expression_1_0 returns StringConstant
	 *     NotEquals_Expression returns StringConstant
	 *     NotEquals_Expression.NotEquals_Expression_1_0 returns StringConstant
	 *     Less_Expression returns StringConstant
	 *     Less_Expression.Less_Expression_1_0 returns StringConstant
	 *     Greater_Expression returns StringConstant
	 *     Greater_Expression.Greater_Expression_1_0 returns StringConstant
	 *     Multiply_Expression returns StringConstant
	 *     Multiply_Expression.Multiply_Expression_1_0 returns StringConstant
	 *     Divide_Expression returns StringConstant
	 *     Divide_Expression.Divide_Expression_1_0 returns StringConstant
	 *     Add_Expression returns StringConstant
	 *     Add_Expression.Add_Expression_1_0 returns StringConstant
	 *     Subtract_Expression returns StringConstant
	 *     Subtract_Expression.Subtract_Expression_1_0 returns StringConstant
	 *     Literal_Expression returns StringConstant
	 *     Constant returns StringConstant
	 *     Single_Constant returns StringConstant
	 *     String_Constant returns StringConstant
	 *
	 * Constraint:
	 *     value=EString
	 * </pre>
	 */
	protected void sequence_String_Constant(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getString_ConstantAccess().getValueEStringParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Subtract_Expression
	 *     And_Expression returns Subtract_Expression
	 *     And_Expression.And_Expression_1_0 returns Subtract_Expression
	 *     Or_Expression returns Subtract_Expression
	 *     Or_Expression.Or_Expression_1_0 returns Subtract_Expression
	 *     Equals_Expression returns Subtract_Expression
	 *     Equals_Expression.Equals_Expression_1_0 returns Subtract_Expression
	 *     NotEquals_Expression returns Subtract_Expression
	 *     NotEquals_Expression.NotEquals_Expression_1_0 returns Subtract_Expression
	 *     Less_Expression returns Subtract_Expression
	 *     Less_Expression.Less_Expression_1_0 returns Subtract_Expression
	 *     Greater_Expression returns Subtract_Expression
	 *     Greater_Expression.Greater_Expression_1_0 returns Subtract_Expression
	 *     Multiply_Expression returns Subtract_Expression
	 *     Multiply_Expression.Multiply_Expression_1_0 returns Subtract_Expression
	 *     Divide_Expression returns Subtract_Expression
	 *     Divide_Expression.Divide_Expression_1_0 returns Subtract_Expression
	 *     Add_Expression returns Subtract_Expression
	 *     Add_Expression.Add_Expression_1_0 returns Subtract_Expression
	 *     Subtract_Expression returns Subtract_Expression
	 *     Subtract_Expression.Subtract_Expression_1_0 returns Subtract_Expression
	 *
	 * Constraint:
	 *     (left=Subtract_Expression_Subtract_Expression_1_0 operator=SubtractOperator right=Literal_Expression)
	 * </pre>
	 */
	protected void sequence_Subtract_Expression(ISerializationContext context, Subtract_Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.SUBTRACT_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.SUBTRACT_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.SUBTRACT_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.SUBTRACT_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, DomainmodelPackage.Literals.SUBTRACT_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainmodelPackage.Literals.SUBTRACT_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubtract_ExpressionAccess().getSubtract_ExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSubtract_ExpressionAccess().getOperatorSubtractOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getSubtract_ExpressionAccess().getRightLiteral_ExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TQL returns TQL
	 *
	 * Constraint:
	 *     blocks+=Block+
	 * </pre>
	 */
	protected void sequence_TQL(ISerializationContext context, TQL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Block returns TargetTable
	 *     Table_Impl returns TargetTable
	 *     Target_Table returns TargetTable
	 *
	 * Constraint:
	 *     (name=EString columns+=Column columns+=Column*)
	 * </pre>
	 */
	protected void sequence_Target_Table(ISerializationContext context, TargetTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Transformation_Call returns TransformationCall
	 *
	 * Constraint:
	 *     (transformation=[Transformation|EString] (callParameters+=Call_Parameter callParameters+=Call_Parameter*)?)
	 * </pre>
	 */
	protected void sequence_Transformation_Call(ISerializationContext context, TransformationCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Block returns Transformation
	 *     Transformation returns Transformation
	 *
	 * Constraint:
	 *     (inType=Type name=EString (parameters+=Parameter parameters+=Parameter*)? outType=Type body=Expression)
	 * </pre>
	 */
	protected void sequence_Transformation(ISerializationContext context, Transformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
