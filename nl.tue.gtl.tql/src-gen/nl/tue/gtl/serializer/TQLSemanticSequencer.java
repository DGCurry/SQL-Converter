/*
 * generated by Xtext 2.27.0
 */
package nl.tue.gtl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import nl.tue.gtl.services.TQLGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import tqlModel.BinaryOperationExpression;
import tqlModel.BooleanConstantExpression;
import tqlModel.FloatConstantExpression;
import tqlModel.InExpression;
import tqlModel.IntegerConstantExpression;
import tqlModel.ParseExpression;
import tqlModel.StringConstantExpression;
import tqlModel.TqlModelPackage;
import tqlModel.parameterExpression;

@SuppressWarnings("all")
public class TQLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TQLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == TqlModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TqlModelPackage.BINARY_OPERATION_EXPRESSION:
				sequence_BinaryOperationExpression(context, (BinaryOperationExpression) semanticObject); 
				return; 
			case TqlModelPackage.BOOLEAN_CONSTANT_EXPRESSION:
				sequence_BooleanConstantExpression(context, (BooleanConstantExpression) semanticObject); 
				return; 
			case TqlModelPackage.FLOAT_CONSTANT_EXPRESSION:
				sequence_FloatConstantExpression(context, (FloatConstantExpression) semanticObject); 
				return; 
			case TqlModelPackage.IN_EXPRESSION:
				sequence_InExpression(context, (InExpression) semanticObject); 
				return; 
			case TqlModelPackage.INTEGER_CONSTANT_EXPRESSION:
				sequence_IntegerConstantExpression(context, (IntegerConstantExpression) semanticObject); 
				return; 
			case TqlModelPackage.PARSE_EXPRESSION:
				sequence_ParseExpression(context, (ParseExpression) semanticObject); 
				return; 
			case TqlModelPackage.STRING_CONSTANT_EXPRESSION:
				sequence_StringConstantExpression(context, (StringConstantExpression) semanticObject); 
				return; 
			case TqlModelPackage.PARAMETER_EXPRESSION:
				sequence_parameterExpression(context, (parameterExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     BinaryOperationExpression returns BinaryOperationExpression
	 *     Expression returns BinaryOperationExpression
	 *
	 * Constraint:
	 *     (operation=BinaryFunction? left=[Expression|EString] right=[Expression|EString])
	 * </pre>
	 */
	protected void sequence_BinaryOperationExpression(ISerializationContext context, BinaryOperationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns BooleanConstantExpression
	 *     ConstantExpression returns BooleanConstantExpression
	 *     BooleanConstantExpression returns BooleanConstantExpression
	 *
	 * Constraint:
	 *     value?='value'
	 * </pre>
	 */
	protected void sequence_BooleanConstantExpression(ISerializationContext context, BooleanConstantExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TqlModelPackage.Literals.BOOLEAN_CONSTANT_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TqlModelPackage.Literals.BOOLEAN_CONSTANT_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanConstantExpressionAccess().getValueValueKeyword_0_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns FloatConstantExpression
	 *     ConstantExpression returns FloatConstantExpression
	 *     FloatConstantExpression returns FloatConstantExpression
	 *
	 * Constraint:
	 *     value=EFloat
	 * </pre>
	 */
	protected void sequence_FloatConstantExpression(ISerializationContext context, FloatConstantExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TqlModelPackage.Literals.FLOAT_CONSTANT_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TqlModelPackage.Literals.FLOAT_CONSTANT_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFloatConstantExpressionAccess().getValueEFloatParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns InExpression
	 *     InExpression returns InExpression
	 *
	 * Constraint:
	 *     (statement=[Expression|EString]? constantSet+=[ConstantExpression|EString] constantSet+=[ConstantExpression|EString]*)
	 * </pre>
	 */
	protected void sequence_InExpression(ISerializationContext context, InExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns IntegerConstantExpression
	 *     ConstantExpression returns IntegerConstantExpression
	 *     IntegerConstantExpression returns IntegerConstantExpression
	 *
	 * Constraint:
	 *     value=EInt
	 * </pre>
	 */
	protected void sequence_IntegerConstantExpression(ISerializationContext context, IntegerConstantExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TqlModelPackage.Literals.INTEGER_CONSTANT_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TqlModelPackage.Literals.INTEGER_CONSTANT_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerConstantExpressionAccess().getValueEIntParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns ParseExpression
	 *     ParseExpression returns ParseExpression
	 *
	 * Constraint:
	 *     (outputType=Type? expression=[Expression|EString])
	 * </pre>
	 */
	protected void sequence_ParseExpression(ISerializationContext context, ParseExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns StringConstantExpression
	 *     ConstantExpression returns StringConstantExpression
	 *     StringConstantExpression returns StringConstantExpression
	 *
	 * Constraint:
	 *     value=EString
	 * </pre>
	 */
	protected void sequence_StringConstantExpression(ISerializationContext context, StringConstantExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TqlModelPackage.Literals.STRING_CONSTANT_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TqlModelPackage.Literals.STRING_CONSTANT_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringConstantExpressionAccess().getValueEStringParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns parameterExpression
	 *     parameterExpression returns parameterExpression
	 *
	 * Constraint:
	 *     {parameterExpression}
	 * </pre>
	 */
	protected void sequence_parameterExpression(ISerializationContext context, parameterExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
