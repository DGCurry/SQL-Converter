// automatically generated by Xtext
grammar nl.tue.gtl.TQL with org.eclipse.xtext.common.Terminals

generate domainmodel "http://www.example.org/domainmodel/TQL"

import "http://www.example.org/model" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

TQL:
	(blocks += Block)*
;

Block:
	Table_Impl | Mapping | Transformation
;

Table_Impl returns Table:
	('source' Source_Table) | 
	('target' Target_Table)
	;	

Column returns Column: name=EString ':' type=Type;

Source_Table returns SourceTable:
	name=EString
	'{'
		 columns+=Column ( "," columns+=Column)* 
	'}';

Target_Table returns TargetTable:
	name=EString
	'{'
		columns+=Column ( "," columns+=Column)* 
	'}';
	
Mapping returns Mapping:
	'mapping' source=[SourceTable|EString] '->' target=[TargetTable|EString]
	('where' where=Expression)?
	'{'
		mappedColumns+=Mapped_Column ( ',' mappedColumns+=Mapped_Column)*
	'}'
;

Mapped_Column returns MappedColumn: 
	target=[Column|EString] ':' source=[Column|EString] ( '|' transformationCalls+=Transformation_Call)*
; 

Transformation_Call returns TransformationCall: 
	transformation=[Transformation|EString] '(' (callParameters+=Call_Parameter ( ',' callParameters+=Call_Parameter )* )? ')'
;

Transformation returns Transformation: 
	'transformation' inType=Type '::' name=EString '(' (parameters+=Parameter ( ',' parameters+=Parameter )* )? ')' ':' outType=Type
	'{'
		body=Statement
	'}'
	;
	
Parameter returns Parameter: name=EString ':' type=Type;

// CallParameters
Call_Parameter returns CallParameter: Constant_Call_Parameter | Reference_Call_Parameter;
Constant_Call_Parameter returns ConstantCallParameter: parameter=Constant;
Reference_Call_Parameter returns ReferenceCallParameter: reference=[Column|EString];

// Expressions
Statement returns Statement: Conditional_Expression | Expression;
Conditional_Expression returns ConditionalExpression: 'if' ifExpression=Expression '{' ifBody=Statement '}' 'else' '{' elseBody=Statement '}';

Expression returns Expression : And_Expression;

And_Expression returns Expression: Or_Expression ({And_Expression.left = current} operator=AndOperator right = Or_Expression)*;
Or_Expression returns Expression: Equals_Expression ({Or_Expression.left = current} operator=OrOperator right = Equals_Expression)*;
Equals_Expression returns Expression: NotEquals_Expression ({Equals_Expression.left = current} operator=EqualsOperator right = NotEquals_Expression)*;
NotEquals_Expression returns Expression: Less_Expression ({NotEquals_Expression.left = current} operator=NotEqualsOperator right = Less_Expression)*;
Less_Expression returns Expression: Greater_Expression ({Less_Expression.left = current} operator=LessOperator right = Greater_Expression)*;
Greater_Expression returns Expression: Multiply_Expression ({Greater_Expression.left = current} operator=GreaterOperator right = Multiply_Expression)*;
Multiply_Expression returns Expression: Divide_Expression ({Multiply_Expression.left = current} operator=MultiplyOperator right = Divide_Expression)*;
Divide_Expression returns Expression: Add_Expression ({Divide_Expression.left = current} operator=DivideOperator right = Add_Expression)*;
Add_Expression returns Expression: Subtract_Expression ({Add_Expression.left = current} operator=AddOperator right = Subtract_Expression)*;
Subtract_Expression returns Expression: Literal_Expression ({Subtract_Expression.left = current} operator=SubtractOperator right = Literal_Expression)*;

Literal_Expression returns Expression: Constant | Parameter_Expression | Self_Expression| Column_Expression; //| Column_Expression TODO for when statement
Column_Expression returns ColumnExpression: column=[Column|EString];
Parameter_Expression returns ParameterExpression: parameter=[Parameter|EString];
Self_Expression returns SelfExpression: {SelfExpression} 'self';

// Constants
Constant returns Constant: Single_Constant | Set_Constant;
Single_Constant returns Constant: Boolean_Constant | Float_Constant | Integer_Constant | String_Constant | Null_Constant;

Boolean_Constant returns BooleanConstant: value=EBoolean;
Float_Constant returns FloatConstant: value=EFloat;
Integer_Constant returns IntegerConstant: value=EInt ;
String_Constant returns StringConstant: '"' value=EString '"';
Null_Constant returns NullConstant: {NullConstant} 'null';
Set_Constant returns SetConstant: {SetConstant} '[' (values+=Single_Constant ( ',' values+=Single_Constant )*)? ']';

EBoolean returns ecore::EBoolean:
	'true' | 'false';

EString returns ecore::EString:
	STRING | ID;
	
EInt returns ecore::EInt:
	'-'? INT;

EFloat returns ecore::EFloat:
	'-'? INT? '.' INT (('E'|'e') '-'? INT)?;
	
enum Type returns Type:
	string = 'string' | integer = 'int' | float = 'float' | date = 'date' | null = 'null' | boolean = 'bool';
	
// We need split the enum for the expression to work	
enum AndOperator returns Operator: and = '&&';
enum OrOperator returns Operator: or = '||';
enum EqualsOperator returns Operator: equals = '==';
enum NotEqualsOperator returns Operator: notEquals = '!=';
enum LessOperator returns Operator: less = '<';
enum GreaterOperator returns Operator: greater = '>';
enum MultiplyOperator returns Operator: multiply = '*';
enum DivideOperator returns Operator: divide = '/';
enum AddOperator returns Operator: add = '+';
enum SubtractOperator returns Operator: subtract = '-';