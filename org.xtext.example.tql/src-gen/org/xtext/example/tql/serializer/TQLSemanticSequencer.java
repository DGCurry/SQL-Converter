/*
 * generated by Xtext 2.27.0
 */
package org.xtext.example.tql.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.tql.domainmodel.DomainmodelPackage;
import org.xtext.example.tql.domainmodel.TQL;
import org.xtext.example.tql.services.TQLGrammarAccess;
import tqlModel.BinaryOperationExpression;
import tqlModel.BooleanConstantExpression;
import tqlModel.BooleanOperationExpression;
import tqlModel.ConditionalStatement;
import tqlModel.FloatConstantExpression;
import tqlModel.InExpression;
import tqlModel.IntegerConstantExpression;
import tqlModel.MappingField;
import tqlModel.MappingSourceTable;
import tqlModel.MappingTargetTable;
import tqlModel.ParseExpression;
import tqlModel.SourceTable;
import tqlModel.StringConstantExpression;
import tqlModel.TableField;
import tqlModel.TargetTable;
import tqlModel.TqlModelPackage;
import tqlModel.Transformation;
import tqlModel.TransformationCall;
import tqlModel.parameterExpression;

@SuppressWarnings("all")
public class TQLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TQLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DomainmodelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DomainmodelPackage.TQL:
				sequence_TQL(context, (TQL) semanticObject); 
				return; 
			}
		else if (epackage == TqlModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TqlModelPackage.BINARY_OPERATION_EXPRESSION:
				sequence_BinaryOperationExpression(context, (BinaryOperationExpression) semanticObject); 
				return; 
			case TqlModelPackage.BOOLEAN_CONSTANT_EXPRESSION:
				sequence_BooleanConstantExpression(context, (BooleanConstantExpression) semanticObject); 
				return; 
			case TqlModelPackage.BOOLEAN_OPERATION_EXPRESSION:
				sequence_BooleanOperationExpression(context, (BooleanOperationExpression) semanticObject); 
				return; 
			case TqlModelPackage.CONDITIONAL_STATEMENT:
				sequence_ConditionalStatement(context, (ConditionalStatement) semanticObject); 
				return; 
			case TqlModelPackage.FLOAT_CONSTANT_EXPRESSION:
				sequence_FloatConstantExpression(context, (FloatConstantExpression) semanticObject); 
				return; 
			case TqlModelPackage.IN_EXPRESSION:
				sequence_InExpression(context, (InExpression) semanticObject); 
				return; 
			case TqlModelPackage.INTEGER_CONSTANT_EXPRESSION:
				sequence_IntegerConstantExpression(context, (IntegerConstantExpression) semanticObject); 
				return; 
			case TqlModelPackage.MAPPING_FIELD:
				sequence_MappingField(context, (MappingField) semanticObject); 
				return; 
			case TqlModelPackage.MAPPING_SOURCE_TABLE:
				sequence_MappingSourceTable(context, (MappingSourceTable) semanticObject); 
				return; 
			case TqlModelPackage.MAPPING_TARGET_TABLE:
				sequence_MappingTargetTable(context, (MappingTargetTable) semanticObject); 
				return; 
			case TqlModelPackage.PARAMETER:
				sequence_Parameter(context, (tqlModel.Parameter) semanticObject); 
				return; 
			case TqlModelPackage.PARSE_EXPRESSION:
				sequence_ParseExpression(context, (ParseExpression) semanticObject); 
				return; 
			case TqlModelPackage.SOURCE_TABLE:
				sequence_Source_Table(context, (SourceTable) semanticObject); 
				return; 
			case TqlModelPackage.STRING_CONSTANT_EXPRESSION:
				sequence_StringConstantExpression(context, (StringConstantExpression) semanticObject); 
				return; 
			case TqlModelPackage.TABLE_FIELD:
				sequence_TableField(context, (TableField) semanticObject); 
				return; 
			case TqlModelPackage.TARGET_TABLE:
				sequence_Target_Table(context, (TargetTable) semanticObject); 
				return; 
			case TqlModelPackage.TRANSFORMATION:
				sequence_Transformation(context, (Transformation) semanticObject); 
				return; 
			case TqlModelPackage.TRANSFORMATION_CALL:
				sequence_TransformationCall(context, (TransformationCall) semanticObject); 
				return; 
			case TqlModelPackage.PARAMETER_EXPRESSION:
				sequence_parameterExpression(context, (parameterExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns BinaryOperationExpression
	 *     BinaryOperationExpression returns BinaryOperationExpression
	 *
	 * Constraint:
	 *     (operation=BinaryFunction? right=[Expression|EString] left=[Expression|EString])
	 * </pre>
	 */
	protected void sequence_BinaryOperationExpression(ISerializationContext context, BinaryOperationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns BooleanConstantExpression
	 *     ConstantExpression returns BooleanConstantExpression
	 *     BooleanConstantExpression returns BooleanConstantExpression
	 *
	 * Constraint:
	 *     value?='value'
	 * </pre>
	 */
	protected void sequence_BooleanConstantExpression(ISerializationContext context, BooleanConstantExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TqlModelPackage.Literals.BOOLEAN_CONSTANT_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TqlModelPackage.Literals.BOOLEAN_CONSTANT_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanConstantExpressionAccess().getValueValueKeyword_0_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns BooleanOperationExpression
	 *     BooleanOperationExpression returns BooleanOperationExpression
	 *
	 * Constraint:
	 *     (operation=BooleanFunction? right=[Expression|EString] left=[Expression|EString])
	 * </pre>
	 */
	protected void sequence_BooleanOperationExpression(ISerializationContext context, BooleanOperationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns ConditionalStatement
	 *     Statement returns ConditionalStatement
	 *     ConditionalStatement returns ConditionalStatement
	 *
	 * Constraint:
	 *     (
	 *         condition=[Expression|EString] 
	 *         booleanoperationexpression=[BooleanOperationExpression|EString] 
	 *         ifBody+=Statement 
	 *         ifBody+=Statement* 
	 *         elseBody+=Statement 
	 *         elseBody+=Statement*
	 *     )
	 * </pre>
	 */
	protected void sequence_ConditionalStatement(ISerializationContext context, ConditionalStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns FloatConstantExpression
	 *     ConstantExpression returns FloatConstantExpression
	 *     FloatConstantExpression returns FloatConstantExpression
	 *
	 * Constraint:
	 *     value=EFloat
	 * </pre>
	 */
	protected void sequence_FloatConstantExpression(ISerializationContext context, FloatConstantExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TqlModelPackage.Literals.FLOAT_CONSTANT_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TqlModelPackage.Literals.FLOAT_CONSTANT_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFloatConstantExpressionAccess().getValueEFloatParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns InExpression
	 *     InExpression returns InExpression
	 *
	 * Constraint:
	 *     (statement=[Expression|EString]? constantSet+=[ConstantExpression|EString] constantSet+=[ConstantExpression|EString]*)
	 * </pre>
	 */
	protected void sequence_InExpression(ISerializationContext context, InExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns IntegerConstantExpression
	 *     ConstantExpression returns IntegerConstantExpression
	 *     IntegerConstantExpression returns IntegerConstantExpression
	 *
	 * Constraint:
	 *     value=EInt
	 * </pre>
	 */
	protected void sequence_IntegerConstantExpression(ISerializationContext context, IntegerConstantExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TqlModelPackage.Literals.INTEGER_CONSTANT_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TqlModelPackage.Literals.INTEGER_CONSTANT_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerConstantExpressionAccess().getValueEIntParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MappingField returns MappingField
	 *
	 * Constraint:
	 *     (souceField=[TableField|EString] targetField=[TableField|EString] (calls+=TransformationCall calls+=TransformationCall*)?)
	 * </pre>
	 */
	protected void sequence_MappingField(ISerializationContext context, MappingField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MappingSourceTable returns MappingSourceTable
	 *
	 * Constraint:
	 *     (name=EString columns+=TableField columns+=TableField*)
	 * </pre>
	 */
	protected void sequence_MappingSourceTable(ISerializationContext context, MappingSourceTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MappingTargetTable returns MappingTargetTable
	 *
	 * Constraint:
	 *     (name=EString columns+=TableField columns+=TableField*)
	 * </pre>
	 */
	protected void sequence_MappingTargetTable(ISerializationContext context, MappingTargetTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (label=EString? type=Type?)
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, tqlModel.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns ParseExpression
	 *     ParseExpression returns ParseExpression
	 *
	 * Constraint:
	 *     (outputType=Type? expression=[Expression|EString])
	 * </pre>
	 */
	protected void sequence_ParseExpression(ISerializationContext context, ParseExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Block returns SourceTable
	 *     Table_Impl returns SourceTable
	 *     Source_Table returns SourceTable
	 *
	 * Constraint:
	 *     (name=EString columns+=TableField columns+=TableField*)
	 * </pre>
	 */
	protected void sequence_Source_Table(ISerializationContext context, SourceTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns StringConstantExpression
	 *     ConstantExpression returns StringConstantExpression
	 *     StringConstantExpression returns StringConstantExpression
	 *
	 * Constraint:
	 *     value=EString
	 * </pre>
	 */
	protected void sequence_StringConstantExpression(ISerializationContext context, StringConstantExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TqlModelPackage.Literals.STRING_CONSTANT_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TqlModelPackage.Literals.STRING_CONSTANT_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringConstantExpressionAccess().getValueEStringParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TQL returns TQL
	 *
	 * Constraint:
	 *     blocks+=Block
	 * </pre>
	 */
	protected void sequence_TQL(ISerializationContext context, TQL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TableField returns TableField
	 *
	 * Constraint:
	 *     (name=EString type=Type)
	 * </pre>
	 */
	protected void sequence_TableField(ISerializationContext context, TableField semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TqlModelPackage.Literals.TABLE_FIELD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TqlModelPackage.Literals.TABLE_FIELD__NAME));
			if (transientValues.isValueTransient(semanticObject, TqlModelPackage.Literals.TABLE_FIELD__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TqlModelPackage.Literals.TABLE_FIELD__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTableFieldAccess().getNameEStringParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTableFieldAccess().getTypeTypeEnumRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Block returns TargetTable
	 *     Table_Impl returns TargetTable
	 *     Target_Table returns TargetTable
	 *
	 * Constraint:
	 *     (name=EString columns+=TableField columns+=TableField*)
	 * </pre>
	 */
	protected void sequence_Target_Table(ISerializationContext context, TargetTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TransformationCall returns TransformationCall
	 *
	 * Constraint:
	 *     (transformation=[Transformation|EString] (parameters+=[TableField|EString] parameters+=[TableField|EString]*)?)
	 * </pre>
	 */
	protected void sequence_TransformationCall(ISerializationContext context, TransformationCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Transformation returns Transformation
	 *
	 * Constraint:
	 *     (
	 *         returnType=Type 
	 *         selfType=Type 
	 *         label=EString 
	 *         returnStatement+=Expression 
	 *         returnStatement+=Expression* 
	 *         (parameter+=Parameter parameter+=Parameter*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Transformation(ISerializationContext context, Transformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns parameterExpression
	 *     parameterExpression returns parameterExpression
	 *
	 * Constraint:
	 *     parameter=[Parameter|EString]
	 * </pre>
	 */
	protected void sequence_parameterExpression(ISerializationContext context, parameterExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TqlModelPackage.Literals.PARAMETER_EXPRESSION__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TqlModelPackage.Literals.PARAMETER_EXPRESSION__PARAMETER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterExpressionAccess().getParameterParameterEStringParserRuleCall_3_0_1(), semanticObject.eGet(TqlModelPackage.Literals.PARAMETER_EXPRESSION__PARAMETER, false));
		feeder.finish();
	}
	
	
}
